locals {
  minio_sa                      = "minio"
  minio_credentials_secret_name = "minio-credentials"
  minio_secret_key_pwd          = "rootPassword"
  minio_secret_key_user         = "rootUser"
  minio_certificate_secret_name = "minio-tls"
  minio_api_hostname            = "minio-api.${var.apps_domain}"
  minio_hostname                = "minio.${var.apps_domain}"
  minio_common_labels = {
    "part-of" = "storage"
  }
}

resource "kubernetes_namespace_v1" "minio" {
  metadata {
    name = "minio"
  }
}

resource "vault_policy" "minio" {
  name   = "minio"
  policy = <<EOT
path "op/vaults/+/items/minio" {
  capabilities = ["read"]
}
EOT
}

resource "vault_kubernetes_auth_backend_role" "minio" {
  role_name                        = "minio"
  bound_service_account_names      = [local.minio_sa]
  bound_service_account_namespaces = [kubernetes_namespace_v1.minio.metadata[0].name]
  token_max_ttl                    = 1440 #24H
  token_policies                   = [vault_policy.minio.name]
}



resource "kubernetes_manifest" "minio_credentials" {
  manifest = {
    apiVersion = "secrets-store.csi.x-k8s.io/v1"
    kind       = "SecretProviderClass"

    metadata = {
      name      = local.minio_credentials_secret_name
      namespace = kubernetes_namespace_v1.minio.metadata[0].name
      labels    = merge(local.minio_common_labels, { component = "credentials" })
    }

    spec = {
      provider = "vault"
      parameters = {
        roleName        = vault_kubernetes_auth_backend_role.minio.role_name
        vaultAddress    = var.vault_address_internal
        vaultCACertPath = var.vault_csi_ca_cert_path #TLS mounted on CSI pod
        objects         = <<EOT
- objectName: password
  secretPath: op/vaults/${var.onepassword_vault_id}/items/minio
  secretKey: password
- objectName: user
  secretPath: op/vaults/${var.onepassword_vault_id}/items/minio
  secretKey: username
        EOT
      }
      # Will become the following K8s secret - Secret needs to have rootPassword and user
      secretObjects = [{
        secretName = local.minio_credentials_secret_name
        type       = "Opaque"
        data = [
          {
            objectName = "password"
            key        = local.minio_secret_key_pwd
          },
          {
            objectName = "user"
            key        = local.minio_secret_key_user
          }
        ]
      }]
    }
  }
}

resource "kubernetes_manifest" "minio_certificate" {
  manifest = {
    apiVersion = "cert-manager.io/v1"
    kind       = "Certificate"
    metadata = {
      name      = local.minio_certificate_secret_name
      namespace = kubernetes_namespace_v1.minio.metadata[0].name
      labels    = merge(local.minio_common_labels, { component = "certificate" })
    }
    spec = {
      secretName  = local.minio_certificate_secret_name
      duration    = "2160h" # 90d
      renewBefore = "360h"  # 15d
      commonName  = local.minio_hostname
      dnsNames = [
        "*.minio.svc.cluster.local",
        "*.minio.svc",
        "*.minio-svc.minio.svc",
        "*.minio",
        "localhost",
        local.minio_api_hostname,
        local.minio_hostname
      ]
      # Although cert manager has a default issuer I need to define here again
      issuerRef = {
        name = var.certificate_cluster_issuer
        kind = "ClusterIssuer"
      }
    }
  }
}

resource "helm_release" "minio" {
  name       = "minio"
  namespace  = kubernetes_namespace_v1.minio.metadata[0].name
  repository = "oci://registry-1.docker.io/bitnamicharts"
  version    = var.minio_chart_version
  chart      = "minio"
  values = [
    <<-EOF
    auth:
      existingSecret: ${kubernetes_manifest.minio_credentials.manifest.metadata.name}
      rootUserSecretKey: ${local.minio_secret_key_user}
      rootPasswordSecretKey: ${local.minio_secret_key_pwd}
    commonLabels: ${jsonencode(merge(local.plex_common_labels, { "component" = "minio" }))}
    tls:
      enabled: true
      autoGenerated:
        enabled: false
      existingCASecret: ${kubernetes_manifest.minio_certificate.manifest.metadata.name}
      server:
        existingSecret: ${kubernetes_manifest.minio_certificate.manifest.metadata.name}
    podSecurityContext:
      enabled: true
      sysctls: []
      supplementalGroups: []
      runAsUser: ${var.minio.user_uid}
      runAsGroup: ${var.minio.group_uid}
      fsGroup: ${var.minio.group_uid}
      fsGroupChangePolicy: "OnRootMismatch"
    containerSecurityContext:
      enabled: true
      seLinuxOptions: {}
      runAsUser: ${var.minio.user_uid}
      runAsGroup: ${var.minio.group_uid}
      runAsNonRoot: true
      privileged: false
      readOnlyRootFilesystem: true
      allowPrivilegeEscalation: false
      capabilities:
        drop: ["ALL"]
      seccompProfile:
        type: "RuntimeDefault"
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
        - weight: 100
          podAffinityTerm:
            labelSelector:
              matchExpressions:
              - key: component
                operator: In
                values:
                - minio
            topologyKey: kubernetes.io/hostname
    hpa:
      enabled: true
      minReplicas: 2
      maxReplicas: 4
      targetCPU: "80"
    persistence:
      enabled: true
      storageClass: persistent
      size: 5Gi
    ingress:
      enabled: true
      hostname: ${local.minio_api_hostname}
      extraTls:
      - hosts:
        - ${local.minio_api_hostname}
        secretName: ${kubernetes_manifest.minio_certificate.manifest.metadata.name}
    console:
      ingress:
        enabled: true
        hostname: ${local.minio_hostname}
        extraTls:
        - hosts:
          - ${local.minio_hostname}
          secretName: ${kubernetes_manifest.minio_certificate.manifest.metadata.name}
    serviceAccount:
      create: true
      name: ${local.minio_sa}
    # Volumes are defined only so CSI Secret Driver can run
    extraVolumeMounts:
    - name: csi-secret-driver-for-minio-credentials
      mountPath: '/mnt/secrets-store'
      readOnly: true
    extraVolumes:
    - name: csi-secret-driver-for-minio-credentials
      csi:
        driver: 'secrets-store.csi.k8s.io'
        readOnly: true
        volumeAttributes:
          secretProviderClass: ${kubernetes_manifest.minio_credentials.manifest.metadata.name}
  EOF
  ]
}